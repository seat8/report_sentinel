# Imports
from email.mime import base
from email.mime.multipart import MIMEMultipart
from email.mime.text import MIMEText
from multiprocessing.sharedctypes import Value
import os
from typing import Dict
import venv

import yaml
import smtplib
import datetime as dt
from pathlib import Path
import subprocess

import logging
import datetime as dt
from yaml.scanner import ScannerError
import pytz

# Set up logging here
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s [%(levelname)s %(message)s",
    handlers=[
        logging.FileHandler("report_sentinel.log"),
        logging.StreamHandler()
    ]
)


# Normal additionals, no need of testing so far they work already
# and have been tested
def load_config(
    file_path: "str|Path" = Path(__file__).parent / 'config.yaml'
) -> "dict":
    try:
        with open(Path(file_path), "r") as file_:
            config: "dict" = yaml.safe_load(file_)
        return config
    except FileNotFoundError:
        raise FileNotFoundError("The provided config path does not exist")
    except ScannerError:
        raise ScannerError(
            "The provided yaml file is not in the correct format"
        )


def get_logger(name: str = 'root', file_: str = 'logs.log') -> None:
    # NOTE: this is not needed for the code so we wont be doing it here,
    # it can be upgraded after
    pass


def send_email(
    smtp_server, sender, recipients,
    username, password, subject, body,
    attachments=[]
) -> None:
    """Sends the provided email using the given parameters"""
    # Parent message object
    msg = MIMEMultipart()
    msg['Subject'] = subject
    msg['From'] = sender
    msg['To'] = ', '.join(recipients)
    # Adding the text part of the message
    msg.attach(MIMEText(body))
    # Add the attachment to the message
    # NOTE: in case of SSL, comment one or the other.
    # with smtplib.SMTP(smtp_server[0], port=smtp_server[1]) as smtp:
    with smtplib.SMTP_SSL(smtp_server[0], port=smtp_server[1]) as smtp:
        smtp.login(username, password)
        smtp.send_message(msg)


def run_tpt_report_downloader(config: Dict):
    """
    Execute TPT report downloader in its virtual environment
    Merges best practices from both implementations with enhanced error
    handling

    Args:
        config: Dictionary containing config params

    Returns:
        bool: True if execution succeeded, False otherwise
    """
    try:
        # Resolve all paths upfront with proper validation
        base_dir = Path(__file__).resolve().parent  # report_sentinel dir
        target_dir = Path(config["main_script_path"]).expanduser()
        venv_dir = (target_dir).resolve().parent / ".venv"

        python_bin = venv_dir / (  # change this to only linux
            "Scripts/python.exe" if os.name == "nt"
            else "bin/python"
        )

        main_py = target_dir / "main.py"
        if not main_py.is_absolute():
            print(('not absolute'))
            main_py = (base_dir / main_py).resolve()
        if not main_py.exists():
            print(f"{main_py} found")
        if main_py.exists():
            print(f"{main_py} found")

        # Create venv if needed
        if not venv_dir.exists():
            print(f"Creating venv for {venv_dir}")
            venv.create(venv_dir, with_pip=True)
            # Install dep if requirements.txt exists
            req_file = target_dir / "requirements.txt"
            if not req_file.exists():
                print('Do not exist')
            if req_file.exists():
                print("Installing dep.")
                subprocess.run(
                    [
                        str(python_bin), "-m", "pip", "install", "-r",
                        str(req_file)
                    ],
                    check=True
                )

        print(f"Running: {main_py}")
        result = subprocess.run(
            [str(python_bin), str(main_py)],
            check=True,
            cwd=target_dir,  # Run from project dir
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            text=True,
            # timeout=300  # 5 minute timeout
        )
        logging.debug(f"TPT output: {result.stdout}")
        return True
    except subprocess.TimeoutExpired:
        logging.error("TPT downloader timed out after 5 minutes")
    except subprocess.CalledProcessError as e:
        logging.error(f"TPT failed (code {e.returncode}): {e.stderr}")
    except Exception as e:
        logging.error(f"Unexpected TPT error: {str(e)}")
    except KeyboardInterrupt:
        logging.debug("Stopped runner")

# another serious part of the code, might break into bits but lets see
# how it goes
# check if last possible report - should be generated by 5PM ET everyday
# expected generated reports are generated 5PM ET, using timestamps gotten
# from file


def current_time_et() -> dt.datetime:
    return dt.datetime.now(pytz.utc).astimezone(
        pytz.timezone("US/Eastern")
    )


def get_expected_report_date() -> dt.date:
    """Calculate last possible report date (previous day 5PM ET cutoff)"""
    now = current_time_et()
    # now = now.replace(minute=0, second=0)
    expected = (now - dt.timedelta(days=1)).date() if now.hour < 17 else now.date()
    # return (now - dt.timedelta(days=1)).date() if now.hour < 17 else now.date()
    print(f"last expected report date was at {expected} and today(ET) is {now}")
    return expected


def check_last_report_exists(report_dir: Path) -> bool:
    """Check if expected report exists in directory using mtime"""
    # report_dir = config["report"]["paths"]
    expected_date = get_expected_report_date()
    expected_file = report_dir / f"{expected_date.strftime('%d-%m-%Y')}.csv"
    print(f"last expected report date was at {expected_date}")

    # if not expected_file.exists():
    #     return False

    # # Only verify mtime for today's xpected reports
    # if expected_date == current_time_et():
    #     # cut_off is 17, which is 5PM ET
    #     cutoff_time = current_time_et().replace(
    #         hour=17, minute=0, second=0, microsecond=0
    #     )
    #     file_mtime = dt.datetime.fromtimestamp(
    #         expected_file.stat().st_mtime, pytz.timezone("US/Eastern")
    #     )
    #     return file_mtime >= cutoff_time

    return expected_file.exists()
    # return True
    # pass


# Main execution
# def main() -> None:
def main(config) -> None:
    # config = read_config_file()
    smtp_server = config["smtp_server"]
    sender = config["sender"]
    recipients = config["errors_recipients"]
    username = config["smtp_username"]
    password = config["smtp_password"]
    subject = ("Last Possible Report Missing")
    try:
        for report_dir in config['report_paths']:
            path = Path(report_dir)
            if not check_last_report_exists(path):  # This is a bool, and it should have the 5PM ET
                body = f"The last possible report in {path} is missing - triggering reprocessing"
                logging.warning(body)
                send_email(
                    smtp_server, sender, recipients, username, password,
                    subject, body
                )
                logging.warning("sent email. YEAAH")
                if run_tpt_report_downloader(config):
                    print("I ran in subprocess")
                    break  # Stop after first reprocessing
    except Exception as e:
        logging.critical(f"Execution failed: {str(e)}")
        # might add send_email here but not important


if __name__ == "__main__":
    config = load_config('config.yaml')
    main(config)
    # Creating the root logger
    # logger = get_logger()
    # run_tpt_report_downloader(config)
    # main(config)
    # get_expected_report_date()
    # check_last_report_exists(config['report_dir'])

# def get_expected_report_date_comp(report_dir=None) -> dt.date:
#     """Calculate last possible report date (previous day 5PM ET cutoff)"""
#     now = dt.datetime.now(pytz.utc).astimezone(
#         pytz.timezone("US/Eastern")
#     )
#     # now = now.replace(minute=0, second=0)
#     # expected = (now - dt.timedelta(days=1)).date() if now.hour < 17 else now.date()
#     # print(f"last expected report date was at {expected.ctime()} and today(ET) is {now.ctime()}")
#     # return expected
#     cutoff_hour = 17

#     if report_dir and report_dir.exists():
#         latest_file_date = None
#         latest_mtime = None

#         # Scan dir for matching files
#         for file in report_dir.glob('*.csv'):
#             try:
#                 # Extract date from filename (dd-mm-YYYY)
#                 # date_str = '_'.join(file.stem.split('_')[1:])
#                 date_str = str(file.stem)
#                 file_date = dt.datetime.strptime(date_str, '%d-%m-%Y').date()
#             except (ValueError, IndexError):
#                 print('An error occured')
#                 continue

#         # if valid file found, calculate expected date
#         if latest_file_date:
#             current_date = now.date()

#             # Before cutoff: expect previous day
#             if now.hour < cutoff_hour:
#                 return latest_file_date - dt.timedelta(days=1)
#             # After cutoff: expect today if file is current
#             elif latest_file_date == current_date:
#                 return current_date
#             # Stale file: expect next day
#             else:
#                 return latest_file_date + dt.timedelta(days=1)

#     # Fallback to time calculation
#     return (now - dt.timedelta(days=1)).date() if now.hour < cutoff_hour else now.date()